from pydantic import ValidationError, BaseModel
from camel.agents import ChatAgent
import re
import json
from json_repair import json_repair


## Using regex to get pure json from answer of planner model
def clean_response_to_str(text: str) -> str: 
    """Cleans string to a string that is compilable by json.loads().
    
    The function extracts JSON code blocks if they are wrapped in triple backticks 
    with the `json` flag (```json ... ```). It then attempts to repair common 
    JSON formatting issues using `json_repair` and regex substitutions.

    Args:
        text (str): input text that was generated by a LLM-agent and is supposed to be structured.

    Returns:
        str: output text that has been validated using regex to be loadable by json.loads().
    """
    # cutting out unnecessary json flags
    match = re.search(r"```json\s*([\s\S]*?)\s*```", text, re.DOTALL)
    if match: 
        json_str = match.group(1)
    else: 
        json_str = text

    # Clean common issues
    cleaned_json = json_repair.repair_json(json_str,)
    cleaned_json = re.sub(r'[\"\']null[\"\']', "null", cleaned_json)

    return cleaned_json


def _get_model_keys(model_class: BaseModel) -> list[str]:
    """Extracts the keys (field names) from a Pydantic model class.

    Args:
        model_class (BaseModel): a generic pydantic model.
    """    
    return list(model_class.model_fields.keys())


def build_model_from_string(input_str: str) -> BaseModel:
    """Builds and validates a Pydantic model from a JSON-like string.

    The function inspects the first part of the input string to infer which 
    specific schema to use (Character, Plot, Setting, or BaseModel). 
    It then cleans the string, parses it into a dictionary, filters out 
    invalid keys, and validates the dictionary against the detected model.

    Args:
        input_str (str): The raw JSON-like string that contains the StoryGlossary str.

    Returns:
        BaseModel: A validated Pydantic model instance of the 
        detected type if parsing and validation succeed, otherwise None.
    """    
    # Find out what specific type of BaseModel the incoming object is, using the first key 
    # of each Schema. To cut time and circumvent errors, the json is sliced first
    model_class : BaseModel
    sliced_json = input_str[:40]
    if "\"name\"" in sliced_json:
        model_class = format.Character
    elif "\"genre\"" in sliced_json:
        model_class = format.Plot
    elif "\"time\"" in sliced_json: 
        model_class = format.Setting
    else:
        model_class = BaseModel

    # Fetch appropriate keys of the provided model
    valid_keys = _get_model_keys(model_class)

    # Clean the JSON string
    cleaned_json_str = clean_response_to_str(input_str)
    
    try:
        # Parse cleaned JSON into a dictionary
        data_dict = json.loads(cleaned_json_str)
        print(f"Brainstorming.py: build_model_from_string(): data_dict: {data_dict}")
        
        # Remove any unnecessary keys that aren't in the valid keys
        filtered_data = {key: value for key, value in data_dict.items() if key in valid_keys}
        print(f"Brainstorming.py: build_model_from_string(): filtered_data: {filtered_data}")
        
        # Validate and return the filtered dictionary
        result_data = model_class.model_validate(filtered_data)
        print(f"Brainstorming.py: build_model_from_string(): character_data: {result_data}")
        return result_data
    
    except json.JSONDecodeError as e:
        print(f"JSON decoding error: {e}")
        print(f"Validation failed at character {e.pos} with character {cleaned_json_str[e.pos]}")
        return None
    except ValidationError as e:
        # write it so the answer of the last round of iteration is used and written into the file
        print(f"Pydantic validation error: {e}")
        return None


def delete_agent_list(agent_list: list[ChatAgent]) -> None:
    """Deletes all agents in the given list.

    Iterates through the provided list and deletes each agent object. 
    After this operation, the agents are no longer accessible, but the 
    list itself is not cleared automatically.

    Args:
        agent_list (list[ChatAgent]): A list of ChatAgent objects to delete.

    Returns:
        None
    """
     # Deleting Agents
    for agent in agent_list:
        del agent
        
        
def extract_title(title: str) -> str: 
    """Extracts the value of the 'title' field from a JSON-like string.

    Uses a regex pattern to find the `"title": "<value>"` entry in the string 
    and returns the value. If no match is found, the original string is returned.

    Args:
        title (str): A JSON-like string containing a 'title' field.

    Returns:
        str: The extracted title if found, otherwise the original input string.
    """
    match = re.search(r'"title":\s*"([^"]+)"', title)
    if match:
        title = match.group(1)   
    return title
    
    
